{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findAll = exports.existsOne = exports.findOne = exports.findOneChild = exports.find = exports.filter = void 0;\nvar domhandler_1 = require(\"domhandler\");\n/**\n * Search a node and its children for nodes passing a test function. If `node` is not an array, it will be wrapped in one.\n *\n * @category Querying\n * @param test Function to test nodes on.\n * @param node Node to search. Will be included in the result set if it matches.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n * @returns All nodes passing `test`.\n */\nfunction filter(test, node, recurse, limit) {\n  if (recurse === void 0) {\n    recurse = true;\n  }\n  if (limit === void 0) {\n    limit = Infinity;\n  }\n  return find(test, Array.isArray(node) ? node : [node], recurse, limit);\n}\nexports.filter = filter;\n/**\n * Search an array of nodes and their children for nodes passing a test function.\n *\n * @category Querying\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n * @returns All nodes passing `test`.\n */\nfunction find(test, nodes, recurse, limit) {\n  var result = [];\n  /** Stack of the arrays we are looking at. */\n  var nodeStack = [nodes];\n  /** Stack of the indices within the arrays. */\n  var indexStack = [0];\n  for (;;) {\n    // First, check if the current array has any more elements to look at.\n    if (indexStack[0] >= nodeStack[0].length) {\n      // If we have no more arrays to look at, we are done.\n      if (indexStack.length === 1) {\n        return result;\n      }\n      // Otherwise, remove the current array from the stack.\n      nodeStack.shift();\n      indexStack.shift();\n      // Loop back to the start to continue with the next array.\n      continue;\n    }\n    var elem = nodeStack[0][indexStack[0]++];\n    if (test(elem)) {\n      result.push(elem);\n      if (--limit <= 0) return result;\n    }\n    if (recurse && (0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {\n      /*\n       * Add the children to the stack. We are depth-first, so this is\n       * the next array we look at.\n       */\n      indexStack.unshift(0);\n      nodeStack.unshift(elem.children);\n    }\n  }\n}\nexports.find = find;\n/**\n * Finds the first element inside of an array that matches a test function. This is an alias for `Array.prototype.find`.\n *\n * @category Querying\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @returns The first node in the array that passes `test`.\n * @deprecated Use `Array.prototype.find` directly.\n */\nfunction findOneChild(test, nodes) {\n  return nodes.find(test);\n}\nexports.findOneChild = findOneChild;\n/**\n * Finds one element in a tree that passes a test.\n *\n * @category Querying\n * @param test Function to test nodes on.\n * @param nodes Node or array of nodes to search.\n * @param recurse Also consider child nodes.\n * @returns The first node that passes `test`.\n */\nfunction findOne(test, nodes, recurse) {\n  if (recurse === void 0) {\n    recurse = true;\n  }\n  var elem = null;\n  for (var i = 0; i < nodes.length && !elem; i++) {\n    var node = nodes[i];\n    if (!(0, domhandler_1.isTag)(node)) {\n      continue;\n    } else if (test(node)) {\n      elem = node;\n    } else if (recurse && node.children.length > 0) {\n      elem = findOne(test, node.children, true);\n    }\n  }\n  return elem;\n}\nexports.findOne = findOne;\n/**\n * Checks if a tree of nodes contains at least one node passing a test.\n *\n * @category Querying\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @returns Whether a tree of nodes contains at least one node passing the test.\n */\nfunction existsOne(test, nodes) {\n  return nodes.some(function (checked) {\n    return (0, domhandler_1.isTag)(checked) && (test(checked) || existsOne(test, checked.children));\n  });\n}\nexports.existsOne = existsOne;\n/**\n * Search an array of nodes and their children for elements passing a test function.\n *\n * Same as `find`, but limited to elements and with less options, leading to reduced complexity.\n *\n * @category Querying\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @returns All nodes passing `test`.\n */\nfunction findAll(test, nodes) {\n  var result = [];\n  var nodeStack = [nodes];\n  var indexStack = [0];\n  for (;;) {\n    if (indexStack[0] >= nodeStack[0].length) {\n      if (nodeStack.length === 1) {\n        return result;\n      }\n      // Otherwise, remove the current array from the stack.\n      nodeStack.shift();\n      indexStack.shift();\n      // Loop back to the start to continue with the next array.\n      continue;\n    }\n    var elem = nodeStack[0][indexStack[0]++];\n    if (!(0, domhandler_1.isTag)(elem)) continue;\n    if (test(elem)) result.push(elem);\n    if (elem.children.length > 0) {\n      indexStack.unshift(0);\n      nodeStack.unshift(elem.children);\n    }\n  }\n}\nexports.findAll = findAll;\n//# sourceMappingURL=querying.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}